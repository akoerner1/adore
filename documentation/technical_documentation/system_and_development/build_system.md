# ADORe Build System

The ADORe build system is a docker build and runtime  environment for ADORe.

## Background
Although ADORe is primarily centered around ROS there is also stand-alone 
components in a conglomeration of technologies such as python, C++ and others.
Each component could have their own respective build and run steps. The primary 
aim of the build system is to normalize complex build processes, as well as, 
provide a containerized runtime for these processes with a focus of 
configuration management of dependencies and software reuse.

## Build interface normalization
The ADORe build system aims to provide per module predictable building and 
testing interfaces via GNU Make such as: 'make build' 'make test' et cetera.

GNU Make is not a new tool however it is stable, familiar to many developers.
For this reason it was selected as the centralized "glue" for the ADORe build
system. GNU Make offers "documentation-as-code" for ADORe capturing complex 
build, testing and execution processes, steps, and commands into a single 
location. To discover the capabilities of a given module or what a module can 
do simple inspect the provided Makefile. It is up to the developer of a module 
to provide interesting or relevant targets for the project or module. At 
minimum 'make build', 'make test' and 'make clean' should be provided by a 
module. Review the [modules](#modules) section for more detail on what constitutes a module.


![adore_if_ros_msg make help Example](images/adore_if_ros_msg_help.jpg)


## Dependency configuration management
In a standard Dockerfile it can be difficult to manage or version system 
dependencies because system dependencies are globed together often on one line. 
The following is a typical example that could be  found in a Dockerfile for 
installing system dependencies following docker "best practices":
```Dockerfile
...
RUN apt-get update && apt-get install -y a b c && \
    rm -rf /var/lib/apt/lists/*
...
```
The problem with this is dependencies tend to change while the build procedure 
may not. In this previous example the dependencies namely a, b, and c are all 
grouped on one line. This makes updating, versioning, tracking/documenting \
(where did the dependency come from or what needs it), and composing dependencies
difficult.

The next example used throughout the ADORe build system adds complexity but also 
has a number of distinct benefits:
```Dockerfile
...
ARG REQUIREMENTS_FILE
...
RUN apt-get update && \
    apt-get install --no-install-recommends -y $(sed '/^#/d' ${REQUIREMENTS_FILE} | sed '/^$/d') && \
    rm -rf /var/lib/apt/lists/*
...
```
The previous example provides the following benefits:
- Dependencies can be tracked in an independent file such as in the case with
adore_if_ros_msg: requirements.adore_if_ros_msg.ubuntu20.04.system
If the base system is changed or upgraded then all that needs to be updated is 
the dependency file.
- There is one dependency per line making visioning easy
- Discovering dependencies within the system is easy
With the following shell command run on the top level of the ADORe project
all dependencies within the project can be discovered: `find -name "requirements.*.ubuntu20.04.system"`
- Composition of dependencies becomes trivial
Building up new docker contexts that pull in dependencies from other modules is 
possible because the dependency files are separate
- Using sed to filter the dependency file allows the use of "#" comments within 
the file. This is useful to documenting and managing individual dependencies.

In general there will be a files/requirements.<module>.<base system>.system file 
that contains all necessary dependencies for that module.  Furhtermore, the
system dependency file 

## Modules
ADORe relies heavily on git submodules for code reuse and boundaries. 
- In general every directory is a module and potentially a stand-alone project
- Every module will provide a Makefile and a Dockerfile 
- Every module will have at minimum a 'build' and 'clean' make target


### Artifacts
Every module will generate artifacts in some form during their respective
life-cycles. This section will detail the possible artifacts.

#### Build artifacts
Every module that produces build artifacts follows the same basic pattern. All 
build artifacts generated by 'make build' will generate a build directory with 
the following path: `<repository name>/<module name>/build`
This could contain binaries, cmake install prefix, headers, Debian packages 
et cetera. 

#### Docker images
In general every module will produce at least a build docker image. If a module
requires a runtime context or other contexts these will be generated as well.
For example on the module libadore located at https://github.com/DLR-TS/
produces the following images:
![Libadore Docker Images](images/libadore_docker_image_ls.jpg)
In the case of libadore there is a docker context for build with will contain
only the build artifacts, a test context which can be used to execute unit tests
and the main context. What docker images/contexts are produced with make build
are dependent on the module needs.

The internal file system layout for each module will be the same and follow the
same pattern.  All project files will be placed in /tmp/<module name>

In the case of project containing ROS packages the structure will be: 
`/tmp/<module name>/<module name>` where the first directory contains the docker
context with Makefile and requirements file and the second directory with the 
same module name will be a standard ROS package with a CMakeLists.txt,
package.xml and any other necessary files. Running 'ls' on the /tmp/libadore 
directory within the libadore build context yields this familiar structure:
![Libadore Docker project directory](images/libadore_ls.jpg)

#### Log artifacts
Some modules produce log output during various life cycle phases for example
during build, test, or execution. This log output will be placed in the 
following path: `<repository name>/.log/`.
Which logs a module generates is wholly dependent on the module in question.
For more information on this please refer to individual documentation within 
a module.

### Module anatomy
The following section will detail the basic anatomy of a module. At minimum 
every module will have a Makefile and a Dockerfile

#### Makefile
At minimum every module should have a Makefile with 'build' and clean 'targets'
defined. The Makefile provides "documentation-as-code" so if you are wondering
what capabilities a module offers the first place to look is the Makefile. 

The makefile also provides important environmental variables for docker build
and docker run such as docker tag and potentially other important environmental
variables relevant to the module.

In general every module should provide a `make help` target to guild users on 
module capabilities. The 'help' target used throughout the ADORe ecosystem is a
spin on the following git gist: https://gist.github.com/prwhite/8168133 and is 
provided by the make_gadgets project at: https://github.com/DLR-TS/make_gadgets.
Any Makefile that has `include make_gadgets/make_gadgets.mk` will have a 
`make help` target. 

Any target or recipe that has two hash symbols such as the following example
Makefile:

![Example Makefile with documented target](images/make_help_makefile.jpg)

Calling make help on would then yield the following on this example module:
![Example make help output](images/make_help.jpg)

As can be seen in the previous image the make_gadgets project also provides
another important recipe/target that is used throughout the ADORe ecosystem 
specifically the "get_sanitized_branch_name". Calling this target returns the
branch name or hash that has been sanitized such that it can be used as a docker
image tag. This will be further detailed in a later section.

For more information on how the help target works please review the 
documentation for https://github.com/DLR-TS/make_gadgets or the gist at 
https://gist.github.com/prwhite/8168133


#### Dockerfile
The Dockerfile is pretty self-explanatory and in general every module will have
a Dockerfile in its root. More dockerfile may be provided by a module if 
necessary depending if the module also requires runtime context.  

#### Interface makefile <modulename>.mk
There are some targets or recipes that are only relevant to the module itself.

<module name>_PROJECT
<module name>_MAKEFILE_PATH
<module name>_SUBMODULES_PATH
<module name>_TAG
<module name>_IMAGE


#### 'files' directory



### Module Composition

![Hierarchic Composition](images/hierarchial_composition.png)
```
git clone git clone --recursive -j8 git@github.com:DLR-TS/adore_if_ros_msg.git
cd adore_if_ros_msg
make build
make test
```

### make build


```text
make build
...
=> => writing image sha256:9061adda9f2b0009dd09d0224a518b950fdb910fc3da005c658aa082f397afad                                                             0.0s 
 => => naming to docker.io/library/adore_if_ros_msg:master                                                                                               0.0s 
docker cp $(docker create --rm adore_if_ros_msg:master):/tmp/adore_if_ros_msg/adore_if_ros_msg/build "/home/akoerner/repos/csa/github.com/DLR-TS/adore_if_ros_msg/adore_if_ros_msg"
Successfully copied 10.6MB to /home/akoerner/repos/csa/github.com/DLR-TS/adore_if_ros_msg/adore_if_ros_msg
...

```

A module can be cloned, built, and tested in isolation.



![Open Composition](images/open_composition.png)
```

```
